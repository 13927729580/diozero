{
  "name": "Diozero",
  "tagline": "Java Device I/O library with an API based on the Python GPIO Zero supporting multiple devices (Raspberry Pi, BeagleBone Black, ...)",
  "body": "# DIO-Zero - a Java Device I/O wrapper for GPIO / I2C / SPI devices\r\n\r\nA Device I/O library written in Java that provides an object-orientated interface for a range of GPIO / I2C / SPI devices such as LEDs, buttons and other various sensors connected to intelligent devices like the Raspberry Pi. Actual GPIO / I2C / SPI device communication is implemented via pluggable service providers for maximum compatibility across different device types.\r\n\r\nThis library makes use of modern Java 8 features such as [automatic resource management](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html), [Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) and [Method References](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html) where they simplify development and improve code readability.\r\n\r\nCreated by [Matt Lewis](https://github.com/mattjlewis) (email [deviceiozero@gmail.com](mailto:deviceiozero@gmail.com)), inspired by [GPIO Zero](https://gpiozero.readthedocs.org/en/v1.1.0/index.html). If you have any issues, comments or suggestions please use [this thread](https://www.raspberrypi.org/forums/viewtopic.php?f=81&t=136010) on the Raspberry Pi forums.\r\n\r\n## Concepts\r\n\r\nThe aim of this library is to encapsulate real-world devices as classes with meaningful operation names, for example LED (on / off), LDR (get luminosity), Button (pressed / released), Motor (forward / backwards / left / right). All devices implement `Closeable` hence will get automatically closed by the `try (Device d = new Device()) { d.doSomething() }` statement. This is best illustrated by some simple examples.\r\n\r\n!!! note\r\n    All pin numbers are device native, i.e. Broadcom for the Raspberry Pi.\r\n\r\nLED control:\r\n\r\n```java\r\ntry (LED led = new LED(pin)) {\r\n\tled.on();\r\n\tSleepUtil.sleepSeconds(.5);\r\n\tled.off();\r\n\tSleepUtil.sleepSeconds(.5);\r\n\tled.toggle();\r\n\tSleepUtil.sleepSeconds(.5);\r\n\tled.toggle();\r\n\tSleepUtil.sleepSeconds(.5);\r\n\tled.blink(0.5f, 0.5f, 10, false);\r\n}\r\n```\r\n\r\nTurn on an LED when you press a button:\r\n\r\n```java\r\ntry (Button button = new Button(buttonPin, GpioPullUpDown.PULL_UP); LED led = new LED(ledPin)) {\r\n\tbutton.whenPressed(led::on);\r\n\tbutton.whenReleased(led::off);\r\n\tSleepUtil.sleepSeconds(10);\r\n}\r\n```\r\n\r\nOr a random LED flicker effect:\r\n\r\n```java\r\ntry (PwmLed led = new PwmLed(pin)) {\r\n\tGpioScheduler.getInstance().invokeAtFixedRate(RANDOM::nextFloat, led::setValue, 50, 50, TimeUnit.MILLISECONDS, false);\r\n}\r\n```\r\n\r\nAll devices are provisioned by a [Device Factory](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/internal/spi/DeviceFactoryInterface.java) with a default [NativeDeviceFactory](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/internal/DeviceFactoryHelper.java) for provisioning via the host board itself. However, all components accept an optional Device Factory parameter for provisioning the same set of components via an alternative method. This is particularly useful for GPIO expansion boards and Analog-to-Digital converters.\r\n\r\nThe Raspberry Pi provides no analog input pins; attempting to create an AnalogInputDevice such as an LDR using the Raspberry Pi default native device factory would result in a runtime error (`UnsupportedOperationException`). However, ADC classes such as the [McpAdc](http://rtd.diozero.com/en/latest/ExpansionBoards/#mcp-adc) have been implemented as analog input device factories hence can be used to construct analog devices such as LDRs:\r\n\r\n```java\r\ntry (McpAdc adc = new McpAdc(McpAdc.Type.MCP3008, chipSelect); LDR ldr = new LDR(adc, pin, vRef, r1)) {\r\n\tSystem.out.println(ldr.getUnscaledValue());\r\n}\r\n```\r\n\r\nRepeating the previous example of controlling an LED when you press a button but with all devices connected via an [MCP23017](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/MCP23017.java) GPIO expansion board:\r\n\r\n```java\r\ntry (MCP23017 mcp23017 = new MCP23017(intAPin, intBPin);\r\n\t\tButton button = new Button(mcp23017, inputPin, GpioPullUpDown.PULL_UP);\r\n\t\tLED led = new LED(mcp23017, outputPin)) {\r\n\tbutton.whenPressed(led::on);\r\n\tbutton.whenReleased(led::off);\r\n\tSleepUtil.sleepSeconds(10);\r\n}\r\n```\r\n\r\nAnalog input devices also provide an event notification mechanism. To control the brightness of an LED based on ambient light levels:\r\n\r\n```java\r\ntry (McpAdc adc = new McpAdc(McpAdc.Type.MCP3008, chipSelect); LDR ldr = new LDR(adc, pin, vRef, r1); PwmLed led = new PwmLed(ledPin)) {\r\n\t// Detect variations of 10%, get values every 50ms (the default)\r\n\tldr.addListener((event) -> led.setValue(1-event.getUnscaledValue()), .1f);\r\n\tSleepUtil.sleepSeconds(20);\r\n}\r\n```\r\n\r\n## Getting Started\r\n\r\nSnapshot builds of the library are available in the [Nexus Repository Manager](https://oss.sonatype.org/index.html#nexus-search;gav~com.diozero~~~~). For convenience a ZIP of all diozero JARs will be maintained on [Google Drive](https://drive.google.com/folderview?id=0B2Kd_bs3CEYaZ3NiRkd4OXhYd3c).\r\n\r\nUnfortunately Java doesn't provide a convenient deployment-time dependency manager such Python's `pip` therefore you will need to manually download all dependencies and setup your classpath correctly. You can do this either via setting the `CLASSPATH` environment variable or as a command-line option (`java -cp <jar1>:<jar2>`). The dependencies have been deliberately kept to as few libraries as possible, as such this library is only dependent on [tinylog](http://www.tinylog.org) [v1.0](https://github.com/pmwmedia/tinylog/releases/download/1.0.3/tinylog-1.0.3.zip).\r\n\r\nTo compile and run a diozero application you will need 4 JAR files - tinylog, diozero-core, one of the supported device provider libraries and the corresponding diozero provider wrapper library.\r\n\r\nProvider | Provider Jar | diozero wrapper-library\r\n-------- | ------------ | -----------------------\r\nJDK Device I/O 1.0 | dio-1.0.1.jar | diozero-provider-jdkdeviceio10-&lt;version&gt;.jar\r\nJDK Device I/O 1.1 | dio-1.1.jar | diozero-provider-jdkdeviceio11-&lt;version&gt;.jar\r\nPi4j | pi4j-core-1.1-SNAPSHOT.jar | diozero-provider-pi4j-&lt;version&gt;.jar\r\nwiringPi | pi4j-core-1.1-SNAPSHOT.jar | diozero-provider-wiringpi-&lt;version&gt;.jar\r\npigpio | pigpioj-java-1.0.0.jar | diozero-provider-pigio-&lt;version&gt;.jar\r\n\r\nTo get started I recommend first looking at the classes in [com.diozero.sampleapps](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/sampleapps/). To run the [LEDTest](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/sampleapps/LEDTest.java) sample application using the pigpioj provider:\r\n\r\nOption 1 - Setting the CLASSPATH environment variable:\r\n```sh\r\nCLASSPATH=tinylog-1.0.3.jar:diozero-core-0.3-SNAPSHOT.jar:diozero-provider-pigpio-0.3-SNAPSHOT.jar:pigpioj-java-1.0.0.jar; export CLASSPATH\r\nsudo java -cp $CLASSPATH com.diozero.sampleapps.LEDTest 12\r\n```\r\n\r\nOption 2 - Setting the classpath via command-line:\r\n```sh\r\nsudo java -cp tinylog-1.0.3.jar:diozero-core-0.3-SNAPSHOT.jar:diozero-provider-pigpio-0.3-SNAPSHOT.jar:pigpioj-java-1.0.0.jar com.diozero.sampleapps.LEDTest 12\r\n```\r\n\r\nFor an experience similar to Python where source code is interpreted rather than compiled try [Groovy](http://www.groovy-lang.org/) (`sudo apt-get update && sudo apt-get install groovy2`). With the `CLASSPATH` environment variable set as per the instructions above, a simple test application can be run via the command `groovy <filename>`. There is also a Groovy shell environment `groovysh`.\r\n\r\nA Groovy equivalent of the LED controlled button example:\r\n\r\n```groovy\r\nimport com.diozero.Button\r\nimport com.diozero.LED\r\nimport com.diozero.util.SleepUtil\r\n\r\nled = new LED(12)\r\nbutton = new Button(25)\r\n\r\nbutton.whenPressed({ led.on() })\r\nbutton.whenReleased({ led.off() })\r\n\r\nprintln(\"Waiting for button presses. Press CTRL-C to quit.\")\r\nSleepUtil.pause()\r\n```\r\n\r\nTo run:\r\n\r\n```sh\r\nsudo groovy -cp $CLASSPATH test.groovy\r\n```\r\n\r\n!!! note \"Groovy JAVA_HOME config when running via sudo\"\r\n    I was getting the error:\r\n    \r\n    `groovy: JAVA_HOME is not defined correctly, can not execute: /usr/lib/jvm/default-java/bin/java`\r\n    \r\n    I tried setting JAVA_HOME in /etc/environment and /etc/profile.d/jdk.sh to no affect. Eventually the following fixed it for me. Please let me know if there is a better way to fix this issue.\r\n    \r\n    ```\r\n    ln -s /usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt /usr/lib/jvm/default-java\r\n    ```\r\n\r\n## Devices\r\n\r\nThis library provides support for a number of GPIO / I2C / SPI connected components and devices, I have categorised them as follows:\r\n\r\n+ [API](http://rtd.diozero.com/en/latest/API/) for lower-level interactions\r\n    - [Input](http://rtd.diozero.com/en/latest/API/#input-devices), [Output](http://rtd.diozero.com/en/latest/API/#output-devices), [I2C](http://rtd.diozero.com/en/latest/API/#i2c-support), [SPI](http://rtd.diozero.com/en/latest/API/#spi-support)\r\n+ [Input Devices](http://rtd.diozero.com/en/latest/InputDevices/)\r\n    - [Digital](http://rtd.diozero.com/en/latest/InputDevices/#digital-input-devices) and [Analog](http://rtd.diozero.com/en/latest/InputDevices/#analog-input-devices)\r\n+ [Output Devices](http://rtd.diozero.com/en/latest/OutputDevices/)\r\n    - [Digital](http://rtd.diozero.com/en/latest/OutputDevices/#digital-led) and [PWM](http://rtd.diozero.com/en/latest/OutputDevices/#pwm-led)\r\n+ [Expansion Boards](http://rtd.diozero.com/en/latest/ExpansionBoards/) for adding additional GPIO / Analog / PWM pins\r\n    - [Microchip Analog to Digital Converters](http://rtd.diozero.com/en/latest/ExpansionBoards/#mcp-adc), [Microchip GPIO Expansion Board](http://rtd.diozero.com/en/latest/ExpansionBoards/#mcp-gpio-expansion-board), [PWM / Servo Driver](http://rtd.diozero.com/en/latest/ExpansionBoards/#pwm-servo-driver)\r\n+ [Motor Control](http://rtd.diozero.com/en/latest/MotorControl/) (support for common motor controller boards)\r\n    - [API](http://rtd.diozero.com/en/latest/MotorControl/#api), [Servos](http://rtd.diozero.com/en/latest/MotorControl/#servo), [CamJam EduKit](http://rtd.diozero.com/en/latest/MotorControl/#camjamkitdualmotor), [Ryanteck](http://rtd.diozero.com/en/latest/MotorControl/#ryanteckdualmotor), [Toshiba TB6612FNG](http://rtd.diozero.com/en/latest/MotorControl/#tb6612fngdualmotordriver)\r\n+ [Sensor Components](http://rtd.diozero.com/en/latest/SensorComponents/) (support for specific sensors, e.g. temperature, pressure, distance, luminosity)\r\n    - [HC-SR04 Ultrasonic Ranging Module](http://rtd.diozero.com/en/latest/SensorComponents/#hc-sr04), [Bosch BMP180](http://rtd.diozero.com/en/latest/SensorComponents/#bosch-bmp180), [TSL2561 Light Sensor](http://rtd.diozero.com/en/latest/SensorComponents/#tsl2561), [1-Wire Temperature Sensors e.g. DS18B20](http://rtd.diozero.com/en/latest/SensorComponents/#1-wire-temperature-sensors)\r\n+ [IMU Devices](http://rtd.diozero.com/en/latest/IMUDevices/) Work-in-progress API for interacting with Inertial Measurement Units such as the InvenSense MPU-9150 and the Analog Devices ADXL345\r\n    - [API](http://rtd.diozero.com/en/latest/IMUDevices/#api), [Supported Devices](http://rtd.diozero.com/en/latest/IMUDevices/#supported-devices)\r\n+ [LED Strips](http://rtd.diozero.com/en/latest/LEDStrips/) Support for LED strips (WS2811B / WS2812B / Adafruit NeoPixel)\r\n    - [WS2811B / WS2812B](http://rtd.diozero.com/en/latest/LEDStrips/#ws281x)\r\n\r\n## Performance\r\n\r\nI've done some limited performance tests (turning a GPIO on then off, see [GpioPerfTest](https://github.com/mattjlewis/diozero/blob/master/diozero-core/src/main/java/com/diozero/sampleapps/GpioPerfTest.java)) on a Raspberry Pi 2 and 3 using the various native device factory providers. I've also run tests using JNI APIs directly without going via my DIO-Zero wrapper to assess the overhead of using my library (see [WiringPiRawPerfTest](https://github.com/mattjlewis/diozero/blob/master/diozero-provider-wiringpi/src/main/java/com/diozero/internal/provider/wiringpi/WiringPiRawPerfTest.java) and [PigpioPerfTest](https://github.com/mattjlewis/pigpioj/blob/master/pigpioj-java/src/main/java/com/diozero/pigpioj/test/PigpioPerfTest.java)) - the overhead is approximately 25% for pigpio and wiringPi. Here are the results:\r\n\r\n| Provider | Device | Frequency (kHz) |\r\n| -------- |:------:| ---------------:|\r\n| Pi4j 1.0 | Pi2 | 0.91 |\r\n| JDK DIO 1.1 | Pi2 | 8.23 |\r\n| Pi4j 1.1 | Pi2 | 622 |\r\n| pigpio | Pi2 | 2,019 |\r\n| pigpio | Pi3 | 2,900 |\r\n| pigpio (JNI) | Pi2 | 2,509 |\r\n| pigpio (JNI) | Pi3 | 3,537 |\r\n| wiringPi | Pi2 | 2,640 |\r\n| wiringPi | Pi3 | 3,446 |\r\n| wiringPi (JNI) | Pi2 | 3,298 |\r\n| wiringPi (JNI) | Pi3 | 4,373 |\r\n\r\n![Performance](images/Performance.png \"Performance\") \r\n\r\nFor a discussion on why Pi4j 1.0 was so slow, see this [issue](https://github.com/Pi4J/pi4j/issues/158). These results are in-line with those documented in the book [\"Raspberry Pi with Java: Programming the Internet of Things\"](http://www.amazon.co.uk/Raspberry-Pi-Java-Programming-Internet/dp/0071842012). For reference, the author's results were:\r\n\r\n| Library | Frequency (kHz) |\r\n|:------- | ---------------:|\r\n|Pi4j 1.0 | 0.751 |\r\n|JDK DIO 1.0 | 3.048 |\r\n|wiringPi (direct) | 1,662 |\r\n\r\n## Development\r\n\r\nThis project is hosted on [GitHub](https://github.com/mattjlewis/diozero/), please feel free to join in:\r\n\r\n+ Make suggestions for [fixes and enhancements](https://github.com/mattjlewis/diozero/issues)\r\n+ Provide sample applications\r\n+ Contribute to development\r\n\r\n## To-Do\r\n\r\nThere is still a lot left to do, in particular:\r\n\r\n+ Thorough testing (various types of devices using each service provider)\r\n+ Testing on different devices (all flavours of Raspberry Pi, BeagleBone, ...)\r\n+ GPIO input debouncing\r\n+ Other I2C & SPI devices, including those on the SenseHAT\r\n+ A clean object-orientated API for IMUs\r\n\r\n## Change-log\r\n\r\n+ Release 0.2: First tagged release\r\n+ Release 0.3: API change - analogue to analog\r\n+ Release 0.4: Bug fixes, servo support\r\n+ Release 0.5: Testing improvements\r\n+ Release 0.6: Preparing for 1.0 release\r\n\r\n## License\r\n\r\nThis work is provided under the [MIT License](http://rtd.diozero.com/en/latest/license/).\r\n",
  "google": "UA-73764647-1",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}